# https://contest.yandex.ru/contest/22779/run-report/112435384/
#
# Итеративный алгоритм для расчета чисел Фибоначчи.
# Так как значение n может быть 10^6, то значения чисел Фибонначи будут иметь огромные порядки. Python позволяет хранить такие числа, однако производительность сильно страдает.
# Поэтому операция нахождения остатка по модулю переносится внутрь цикла, чтобы значения текущего и предыдущего элемента были порядка не более k (k <= 8).
# Результат будет верен, так как происходит суммирование чисел, а последние k элементов при суммировании не зависят от значений в порядках старше k.
#
#
# Временная сложность - O(N). Итерация производится от 2 до n+1. Внутри цикла операции сложения и остатка от деления производятся за O(1).
# Сложность по памяти - O(1). Накладные ресурсы - две вспомогательных переменных a и b, не зависят от n


def fibonacci_mod(n: int, mod: int) -> int:
    if n < 2:
        return 1

    a, b = 1, 1

    for _ in range(2, n + 1):
        a, b = b % mod, (a + b) % mod

    return b


def main():
    n, k = map(int, input().split())

    value = fibonacci_mod(n, 10 ** k)
    print(value)


if __name__ == '__main__':
    main()
